<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Mon Jan  4 23:22:25 2021 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>json</title>

</head>
<body>

<h1 align="center">json</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#PATHS">PATHS</a><br>
<a href="#TEMPLATES">TEMPLATES</a><br>
<a href="#EXCEPTIONS">EXCEPTIONS</a><br>
<a href="#EXAMPLES">EXAMPLES</a><br>
<a href="#KEYWORDS">KEYWORDS</a><br>

<hr>



<p>______________________________________________________________________________</p>

<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">json &minus;
Parse, manipulate and produce JSON documents</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>package
require rl_json</b> ?<b>0.11.0</b>?</p>

<p style="margin-left:11%; margin-top: 1em"><b>json get</b>
<i>jsonValue</i> ?<i>key ...</i>? <b><br>
json extract</b> <i>jsonValue</i> ?<i>key ...</i>? <b><br>
json exists</b> <i>jsonValue</i> ?<i>key ...</i>? <b><br>
json set</b> <i>jsonVariableName</i> ?<i>key ...</i>?
<i>value</i> <b><br>
json unset</b> <i>jsonVariableName</i> ?<i>key ...</i>?
<b><br>
json foreach</b> <i>varlist1 jsonValue1</i> ?<i>varlist2
jsonValue2 ...</i>? <i>script</i> <b><br>
json lmap</b> <i>varlist1 jsonValue1</i> ?<i>varlist2
jsonValue2 ...</i>? <i>script</i> <b><br>
json amap</b> <i>varlist1 jsonValue1</i> ?<i>varlist2
jsonValue2 ...</i>? <i>script</i> <b><br>
json omap</b> <i>varlist1 jsonValue1</i> ?<i>varlist2
jsonValue2 ...</i>? <i>script</i> <b><br>
json string</b> <i>value</i> <b><br>
json number</b> <i>value</i> <b><br>
json boolean</b> <i>value</i> <b><br>
json object</b> <i>?key value ?key value ...??</i> <b><br>
json array</b> <i>elem ...</i> <b><br>
json bool</b> <i>value</i> <b><br>
json normalize</b> <i>jsonValue</i> <b><br>
json pretty</b> <i>jsonValue</i> <b><br>
json template</b> <i>jsonValue</i> ?<i>dictionary</i>?
<b><br>
json isnull</b> <i>jsonValue</i> ?<i>key ...</i>? <b><br>
json type</b> <i>jsonValue</i> ?<i>key ...</i>? <b><br>
json length</b> <i>jsonValue</i> ?<i>key ...</i>? <b><br>
json keys</b> <i>jsonValue</i> ?<i>key ...</i>? <b><br>
json decode</b> <i>bytes</i> ?<i>encoding</i>? <b><br>
json valid ?-extensions</b> <i>extensionlist</i>?
?<b>-details</b> <i>detailsvar</i>? <i>jsonValue</i>
______________________________________________________________________________</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This package
adds a command <b>json</b> to the interpreter, and defines a
new Tcl_Obj type to store the parsed JSON document. The
<b>json</b> command directly manipulates values whose string
representation is valid JSON, in a similar way to how the
<b>dict</b> command directly manipulates values whose string
representation is a valid dictionary. It is similar to
<b>dict</b> in performance. <b><br>
json get</b> <i>jsonValue</i> ?<i>key ...</i>?</p>

<p style="margin-left:22%;">Extract the value of a portion
of the <i>jsonValue</i>, returns the closest native Tcl type
(other than JSON) for the extracted portion. The <i>key
...</i> arguments are a path, as described in <b>PATHS</b>
below.</p>

<p style="margin-left:11%;"><b>json extract</b>
<i>jsonValue</i> ?<i>key ...</i>?</p>

<p style="margin-left:22%;">Extract the value of a portion
of the <i>jsonValue</i>, returns the JSON fragment. The
<i>key ...</i> arguments are a path, as described in
<b>PATHS</b> below.</p>

<p style="margin-left:11%;"><b>json exists</b>
<i>jsonValue</i> ?<i>key ...</i>?</p>

<p style="margin-left:22%;">Tests whether the supplied key
path (see <b>PATHS</b> below) resolves to something that
exists in <i>jsonValue</i> (i.e., that it can be used with
<b>json get</b> without error) and is not null. Returns
false if the value named by the path <i>key ...</i> is
null.</p>

<p style="margin-left:11%;"><b>json set</b>
<i>jsonVariableName</i> ?<i>key ...</i>? <i>value</i></p>

<p style="margin-left:22%;">Updates the JSON value stored
in the variable <i>jsonVariableName</i>, replacing the value
referenced by <i>key ...</i> (a path as described in
<b>PATHS</b> below) with the JSON value <i>value</i>. If
<i>value</i> is a valid JSON as given by the JSON grammar,
it is added as that JSON type, otherwise it is converted to
a JSON string. Thus the following are equivalent (modulo
efficiency):</p>

<p style="margin-left:22%; margin-top: 1em">json set doc
foo [json string baz] <br>
json set doc bar [json number 123] <br>
json set doc baz [json boolean true]</p>


<p style="margin-left:22%; margin-top: 1em">#------------------------------------------
<br>
json set doc foo baz <br>
json set doc bar 123 <br>
json set doc baz true</p>

<p style="margin-left:11%; margin-top: 1em">Watch out for
unintended behaviour if the value might look like a boolean
or number but not meet the JSON grammar for those types, in
which case the value is converted to a JSON string:</p>

<p style="margin-left:22%; margin-top: 1em">json set doc
foo [json boolean yes] <br>
# Key &quot;foo&quot; contains the JSON boolean value
&quot;true&quot;</p>

<p style="margin-left:22%; margin-top: 1em">json set doc
foo yes <br>
# Key &quot;foo&quot; contains the JSON string value
&quot;yes&quot;</p>

<p style="margin-left:11%; margin-top: 1em">Constructing
the values using [<b>json</b> <i>type</i>] forces the
conversion to the specified JSON type, or throws an
exception if that can&rsquo;t be done. Which is more
efficent will depend on the situation:</p>

<p style="margin-left:22%; margin-top: 1em">set doc {[]}
<br>
for {set i 0} {$i &lt; 100} {incr i} {</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="3%"></td>
<td width="5%"></td>
<td width="92%">


<p>json set doc end+1 [json boolean true];# 1</p></td></tr>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="5%"></td>
<td width="92%">


<p>json set doc end+1 true;# 2</p></td></tr>
</table>

<p style="margin-left:22%;">} <br>
# 2 will be faster since &quot;true&quot; will be stored as
a literal, and converted <br>
# to a JSON boolean. Each loop iteration will just append
another reference <br>
# to this static value to the array, whereas 1 will call
[json boolean] each <br>
# iteration.</p>

<p style="margin-left:22%; margin-top: 1em">set doc {[]}
<br>
for {set i 0} {$i &lt; 100} {incr i} {</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="3%"></td>
<td width="97%">


<p>json set doc end+1 [json string false$i];# 1</p></td></tr>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="97%">


<p>json set doc end+1 false$i;# 2</p></td></tr>
</table>

<p style="margin-left:22%;">} <br>
# 1 will be faster since [json string] knows what the type
is and directly <br>
# creates the new element as that type. 2 Needs to parse the
string to <br>
# determine the type.</p>

<p style="margin-left:11%;"><b>json unset</b>
<i>jsonVariableName</i> ?<i>key ...</i>?</p>

<p style="margin-left:22%;">Updates the JSON value stored
in the variable <i>jsonVariableName</i>, removing the value
referenced by <i>key ...</i>, a path as described in
<b>PATHS</b> below. If the path names a entry in an object
then that key is removed from the object. If the path names
an element in an array, that element is removed and all
later elements are moved up.</p>

<p style="margin-left:11%;"><b>json template</b>
<i>jsonValue</i> ?<i>dictionary</i>?</p>

<p style="margin-left:22%;">Return a JSON value by
interpolating the values from <i>dictionary</i> into the
template, or from variables in the current scope if
<i>dictionary</i> is not supplied, in the manner described
in the section <b>TEMPLATES</b>.</p>

<p style="margin-left:11%;"><b>json string</b>
<i>value</i></p>

<p style="margin-left:22%;">Return a JSON string with the
value <i>value</i>.</p>

<p style="margin-left:11%;"><b>json number</b>
<i>value</i></p>

<p style="margin-left:22%;">Return a JSON number with the
value <i>value</i>.</p>

<p style="margin-left:11%;"><b>json boolean</b>
<i>value</i></p>

<p style="margin-left:22%;">Return a JSON boolean with the
value <i>value</i>. Any of the forms accepted by
Tcl_GetBooleanFromObj are accepted and normalized.</p>

<p style="margin-left:11%;"><b>json object</b> <i>?key
value ?key value ...??</i> -or- <b>json object</b>
<i>packed_value</i></p>

<p style="margin-left:22%;">Return a JSON object with the
each of the keys and values given. <i>value</i> is a list of
two elements, the first being the type {string, number,
boolean, null, object, array, json}, and the second being
the value. The alternate syntax <b>json object</b>
<i>packed_value</i> takes the list of keys and values as a
single arg instead of a list of args, but is otherwise the
same.</p>

<p style="margin-left:11%;"><b>json array</b> <i>?elem
...?</i></p>

<p style="margin-left:22%;">Return a JSON array containing
each of the elements given. <i>elem</i> is a list of two
elements, the first being the type {string, number, boolean,
null, object, array, json}, and the second being the
value.</p>

<p style="margin-left:11%;"><b>json foreach</b> <i>varList1
jsonValue1</i> ?<i>varList2 jsonValue2 ...</i>?
<i>script</i></p>

<p style="margin-left:22%;">Evaluate <i>script</i> in a
loop in a similar way to the <b>foreach</b> command. In each
iteration, the values stored in the iterator variables in
each <i>varList</i> are the JSON fragments from
<i>jsonValue</i>. This command supports iterating over JSON
arrays and JSON objects. In the JSON object case, the
corresponding <i>varList</i> must be a two element list,
with the first specifiying the variable to hold the key and
the second the value. In the JSON array case, the rules are
the same as the <b>foreach</b> command.</p>

<p style="margin-left:11%;"><b>json lmap</b> <i>varList1
jsonValue1</i> ?<i>varList2 jsonValue2 ...</i>?
<i>script</i></p>

<p style="margin-left:22%;">As for <b>json foreach</b>,
except that it is collecting; the result from each
evaluation of <i>script</i> is added to a Tcl list and
returned as the result of the <b>json lmap</b> command. If
the <i>script</i> results in a TCL_CONTINUE code (e.g., the
script does <b>continue</b>), that iteration is skipped and
no element is added to the result list. If it results in
TCL_BREAK (e.g., the script does <b>break</b>) the
iterations are stopped and the results accumulated so far
are returned.</p>

<p style="margin-left:11%;"><b>json amap</b> <i>varList1
jsonValue1</i> ?<i>varList2 jsonValue2 ...</i>?
<i>script</i></p>

<p style="margin-left:22%;">As for <b>json lmap</b>, but
the result is a JSON array rather than a list. If the result
of each iteration is a JSON value it is added to the array
as-is, otherwise it is converted to a JSON string.</p>

<p style="margin-left:11%;"><b>json omap</b> <i>varList1
jsonValue1</i> ?<i>varList2 jsonValue2 ...</i>?
<i>script</i></p>

<p style="margin-left:22%;">As for <b>json lmap</b>, but
the result is a JSON object rather than a list. The result
of each iteration must be a dictionary (or a list of 2n
elements, including n = 0). Tcl_ObjType snooping is done to
ensure that the iteration over the result is efficient for
both dict and list cases. Each entry in the dictionary will
be added to the result object. If the value for each key in
the iteration result is a JSON value it is added to the
array as-is, otherwise it is converted to a JSON string.</p>

<p style="margin-left:11%;"><b>json isnull</b>
<i>jsonVariableName</i> ?<i>key ...</i>?</p>

<p style="margin-left:22%;">Return a boolean indicating
whether the named JSON value is null.</p>

<p style="margin-left:11%;"><b>json type</b>
<i>jsonVariableName</i> ?<i>key ...</i>?</p>

<p style="margin-left:22%;">Return the type of the named
JSON value, one of &quot;object&quot;, &quot;array&quot;,
&quot;string&quot;, &quot;number&quot;, &quot;boolean&quot;
or &quot;null&quot;.</p>

<p style="margin-left:11%;"><b>json length</b>
<i>jsonVariableName</i> ?<i>key ...</i>?</p>

<p style="margin-left:22%;">Return the length of the of the
named JSON array, number of entries in the named JSON
object, or number of characters in the named JSON string.
Other value types aren&rsquo;t supported.</p>

<p style="margin-left:11%;"><b>json keys</b>
<i>jsonVariableName</i> ?<i>key ...</i>?</p>

<p style="margin-left:22%;">Return the keys in the of the
named JSON object, found by following the path of
<i>key</i>s.</p>

<p style="margin-left:11%;"><b>json normalize</b>
<i>jsonValue</i></p>

<p style="margin-left:22%;">Return a
&ldquo;normalized&rdquo; version of the input
<i>jsonValue</i>, i.e., with all optional whitespace
trimmed.</p>

<p style="margin-left:11%;"><b>json pretty</b>
<i>jsonValue</i></p>

<p style="margin-left:22%;">Returns a pretty-printed string
representation of <i>jsonValue</i>. Useful for debugging or
inspecting the structure of JSON data.</p>

<p style="margin-left:11%;"><b>json decode</b> <i>bytes</i>
?<i>encoding</i>?</p>

<p style="margin-left:22%;">Rl_json operates on characters,
as returned from Tcl&rsquo;s Tcl_GetStringFromObj, not raw
bytes, so considerations of encoding are strictly outside of
its scope (other than ignoring a byte order mark if the
string starts with one). The JSON RFC lays out some
behaviour for conforming implementations regarding character
encoding, and ensuring that an application using rl_json
meets that standard would be up to the application. Some
aspects are not straightforward, so rl_json provides this
utility subcommand that takes binary data in <i>bytes</i>
and returns a character string according to the RFC
specified behaviour. If the optional <i>encoding</i>
argument is given, that encoding will be used to interpret
<i>bytes</i>. The supported encodings are those specified in
the RFC: utf-8, utf-16le, utf-16be, utf-32le, utf-32be. If
the string starts with a BOM (byte order mark (U+FFFE)), and
no encoding is given, it will be determined from the
encoding of the BOM. All the encodings listed are supported,
even if Tcl lacks support for the utf-16 and utf-32
encodings natively. However, without native support the
conversion will be slow.</p>

<p style="margin-left:22%; margin-top: 1em">This might look
something like this in an application:</p>

<p style="margin-left:22%; margin-top: 1em">proc readjson
file {</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="3%"></td>
<td width="5%"></td>
<td width="3%"></td>
<td width="89%">


<p>set h [open $file rb];# Note that the file is opened in
binary mode - no encoding</p></td></tr>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="5%"></td>
<td width="3%"></td>
<td width="89%">


<p>try {</p></td></tr>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="5%"></td>
<td width="3%"></td>
<td width="89%">
</td></tr>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="5%"></td>
<td width="3%"></td>
<td width="89%">
</td></tr>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="5%"></td>
<td width="3%"></td>
<td width="89%">


<p>json decode [read $h]</p></td></tr>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="5%"></td>
<td width="3%"></td>
<td width="89%">


<p>} finally {</p></td></tr>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="5%"></td>
<td width="3%"></td>
<td width="89%">
</td></tr>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="5%"></td>
<td width="3%"></td>
<td width="89%">
</td></tr>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="5%"></td>
<td width="3%"></td>
<td width="89%">


<p>close $h</p></td></tr>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="5%"></td>
<td width="3%"></td>
<td width="89%">


<p>}</p></td></tr>
</table>

<p style="margin-left:22%;">}</p>

<p style="margin-left:11%;"><b>json valid</b>
?<b>-extensions</b> <i>extensionlist</i>? ?<b>-details</b>
<i>details</i>? <i>jsonValue</i></p>

<p style="margin-left:22%;">Validate <b>jsonValue</b>
against the JSON grammar, returning true if it conforms and
false otherwise. A list of extensions to accept can be
supplied with <b>-extensions</b>, with only one currently
supported extension: <b>comments</b>, which accepts JSON
documents containing <b>// foo</b> and <b>/* foo */</b>
style comments anywhere whitespace would be valid. To reject
documents containing comments, set <i>extensionlist</i> to
{}.</p>

<p style="margin-left:22%; margin-top: 1em">Validation
using this subcommand is about 3 times faster than parsing
and catching a parsing exception, and it allows strict
validation against the RFC without comments.</p>

<p style="margin-left:22%; margin-top: 1em">If validation
fails and <b>-details</b> <i>detailsvar</i> is supplied, the
variable <i>detailsvar</i> is set to a dictionary containing
the keys:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="26%"></td>
<td width="12%">


<p><b>errmsg</b></p></td>
<td width="4%"></td>
<td width="58%">


<p>A reason for the failure.</p></td></tr>
<tr valign="top" align="left">
<td width="26%"></td>
<td width="12%">


<p><b>doc</b></p></td>
<td width="4%"></td>
<td width="58%">


<p>The document that failed validation</p></td></tr>
<tr valign="top" align="left">
<td width="26%"></td>
<td width="12%">


<p><b>char_ofs</b></p></td>
<td width="4%"></td>
<td width="58%">


<p>The character offset into <b>doc</b> that caused
validation to fail.</p></td></tr>
</table>

<h2>PATHS
<a name="PATHS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Several of the
commands (e.g., <b>json get</b>, <b>json exists</b>, <b>json
set</b> and <b>json unset</b>) accept a path specification
that names some subset of the supplied <i>jsonValue</i>. The
rules are similar to the equivalent concept in the
<b>dict</b> command, except that the paths used by
<b>json</b> allow indexing into JSON arrays by the integer
key (or a string matching the regex
&ldquo;^end(-[0-9]+)?$&rdquo;).</p>

<h2>TEMPLATES
<a name="TEMPLATES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The command
<b>json template</b> generates JSON documents by
interpolating values into a template from a supplied
dictionary or variables in the current call frame, a
flexible mechanism for generating complex documents. The
templates are valid JSON documents containing string values
which match the regex &ldquo;^~[SNBJTL]:.+$&rdquo;. The
second character determines what the resulting type of the
substituted value will be:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p style="margin-top: 1em"><b>S</b></p></td>
<td width="3%"></td>
<td width="80%">


<p style="margin-top: 1em">A string.</p></td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p><b>N</b></p></td>
<td width="3%"></td>
<td width="80%">


<p>A number.</p></td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p><b>B</b></p></td>
<td width="3%"></td>
<td width="80%">


<p>A boolean.</p></td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p><b>J</b></p></td>
<td width="3%"></td>
<td width="80%">


<p>A JSON fragment.</p></td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p><b>T</b></p></td>
<td width="3%"></td>
<td width="80%">


<p>A JSON template (substitutions are performed on the
inserted fragment).</p></td></tr>
<tr valign="top" align="left">
<td width="15%"></td>
<td width="2%">


<p><b>L</b></p></td>
<td width="3%"></td>
<td width="80%">


<p>A literal. The resulting string is simply everything
from the fourth character onwards (this allows literal
strings to be included in the template that would otherwise
be interpreted as the substitutions above).</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">None of the
first three characters for a template may be escaped.</p>

<p style="margin-left:11%; margin-top: 1em">The value
inserted is determined by the characters following the
substitution type prefix. When interpolating values from a
dictionary they name keys in the dictionary which hold the
values to interpolate. When interpolating from variables in
the current scope, they name scalar or array variables which
hold the values to interpolate. In either case if the named
key or variable doesn&rsquo;t exist, a JSON null is
interpolated in its place.</p>

<h2>EXCEPTIONS
<a name="EXCEPTIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Exceptions are
thrown when attempting to parse a string which isn&rsquo;t
valid JSON, or when a named path is invalid or doesn&rsquo;t
exist: <b><br>
RL JSON PARSE</b> <i>errormessage string charOfs</i></p>

<p style="margin-left:22%;">Thrown when trying to parse a
string that isn&rsquo;t valid JSON. The <i>string</i>
element contains the string that failed to parse, and the
first invalid character is at offset <i>charOfs</i> within
that string, using 0 based offsets.</p>

<p style="margin-left:11%;"><b>RL JSON BAD_PATH</b>
<i>path</i></p>

<p style="margin-left:22%;">Thrown when indexing into a
JSON value and the specified path isn&rsquo;t valid.
<i>path</i> is the left subset of the path up to first
element that caused the failure.</p>

<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Produce a JSON
value from a template:</p>

<p style="margin-left:22%; margin-top: 1em"><b>json
template</b> { <br>
{ <br>
&quot;thing1&quot;: &quot;~S:val1&quot;, <br>
&quot;thing2&quot;: [&quot;a&quot;, &quot;~N:val2&quot;,
&quot;~S:val2&quot;, &quot;~B:val2&quot;, <br>
&quot;~S:val3&quot;, &quot;~L:~S:val1&quot;], <br>
&quot;subdoc1&quot;: &quot;~J:subdoc&quot;, <br>
&quot;subdoc2&quot;: &quot;~T:subdoc&quot; <br>
} <br>
} { <br>
val1 hello <br>
val2 1e6 <br>
subdoc { <br>
{ &quot;thing3&quot;: &quot;~S:val1&quot; } <br>
} <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">The result
(with formatting for readability):</p>

<p style="margin-left:22%; margin-top: 1em">{ <br>
&quot;thing1&quot;:&quot;hello&quot;, <br>

&quot;thing2&quot;:[&quot;a&quot;,1000000.0,&quot;1e6&quot;,true,null,&quot;~S:val1&quot;],
<br>

&quot;subdoc1&quot;:{&quot;thing3&quot;:&quot;~S:val1&quot;},
<br>
&quot;subdoc2&quot;:{&quot;thing3&quot;:&quot;hello&quot;}
<br>
}</p>

<p style="margin-left:11%; margin-top: 1em">Incrementally
append an element to an array (similar to <b>dict
lappend</b>):</p>

<p style="margin-left:22%; margin-top: 1em">set doc
{{&quot;foo&quot;:[]}} <br>
for {set i 0} {$i &lt; 4} {incr i} { <br>
json set doc foo end+1 [json string &quot;elem: $i&quot;]
<br>
} <br>
# $doc is {&quot;foo&quot;:[&quot;elem 0&quot;,&quot;elem
1&quot;,&quot;elem 2&quot;,&quot;elem 3&quot;]}</p>

<p style="margin-left:11%; margin-top: 1em">Similar to the
above, but prepend the elements instead:</p>

<p style="margin-left:22%; margin-top: 1em">set doc
{{&quot;foo&quot;:[]}} <br>
for {set i 0} {$i &lt; 4} {incr i} { <br>
json set doc foo -1 [json string &quot;elem: $i&quot;] <br>
} <br>
# $doc is {&quot;foo&quot;:[&quot;elem 3&quot;,&quot;elem
2&quot;,&quot;elem 1&quot;,&quot;elem 0&quot;]}</p>

<p style="margin-left:11%; margin-top: 1em">Trim an element
out of an array:</p>

<p style="margin-left:22%; margin-top: 1em">set doc
{[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]} <br>
json unset doc 1 <br>
# $doc is {[&quot;a&quot;,&quot;c&quot;]}</p>

<p style="margin-left:11%; margin-top: 1em">Implicitly
create objects when setting a path that doesn&rsquo;t
exist:</p>

<p style="margin-left:22%; margin-top: 1em">set doc
{{&quot;foo&quot;:1}} <br>
json set doc bar baz {&quot;hello, new obj&quot;} <br>
# $doc is
{&quot;foo&quot;:1,&quot;bar&quot;:{&quot;baz&quot;:&quot;hello,
new obj&quot;}}</p>

<p style="margin-left:11%; margin-top: 1em">Index through
objects and arrays (the path elements are unambiguous
because the json types they index into are known at resolve
time):</p>

<p style="margin-left:22%; margin-top: 1em">set doc
{{&quot;foo&quot;:[&quot;a&quot;,{&quot;primes&quot;:[2,3,5,7,11,13,17,19]},&quot;c&quot;]}}
<br>
json get $doc foo 1 primes end-1 <br>
# returns 17</p>

<p style="margin-left:11%; margin-top: 1em">Handle a parse
error and display a helpful message indicating the character
that caused the failure:</p>

<p style="margin-left:22%; margin-top: 1em">try { <br>
json get { <br>
{ <br>
&quot;foo&quot;: { <br>
&quot;bar&quot;: true, <br>
} <br>
} <br>
} foo bar <br>
} trap {RL JSON PARSE} {errmsg options} { <br>
lassign [lrange [dict get $options -errorcode] 4 5] doc
char_ofs <br>
puts stderr &quot;$errmsg\n[string range $doc 0
$char_ofs-1](here --&gt;)[string range $doc $char_ofs
end]&quot; <br>
}</p>

<p style="margin-left:11%; margin-top: 1em">Produces:</p>

<p style="margin-left:22%; margin-top: 1em">Error parsing
JSON value: Illegal character at offset 37</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="3%"></td>
<td width="5%"></td>
<td width="3%"></td>
<td width="4%"></td>
<td width="85%">
</td></tr>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="5%"></td>
<td width="3%"></td>
<td width="4%"></td>
<td width="85%">
</td></tr>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="5%"></td>
<td width="3%"></td>
<td width="4%"></td>
<td width="85%">


<p>{</p></td></tr>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="5%"></td>
<td width="3%"></td>
<td width="4%"></td>
<td width="85%">
</td></tr>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="5%"></td>
<td width="3%"></td>
<td width="4%"></td>
<td width="85%">
</td></tr>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="5%"></td>
<td width="3%"></td>
<td width="4%"></td>
<td width="85%">
</td></tr>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="5%"></td>
<td width="3%"></td>
<td width="4%"></td>
<td width="85%">


<p>&quot;foo&quot;: {</p></td></tr>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="5%"></td>
<td width="3%"></td>
<td width="4%"></td>
<td width="85%">
</td></tr>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="5%"></td>
<td width="3%"></td>
<td width="4%"></td>
<td width="85%">
</td></tr>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="5%"></td>
<td width="3%"></td>
<td width="4%"></td>
<td width="85%">
</td></tr>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="5%"></td>
<td width="3%"></td>
<td width="4%"></td>
<td width="85%">
</td></tr>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="5%"></td>
<td width="3%"></td>
<td width="4%"></td>
<td width="85%">


<p>&quot;bar&quot;: true,</p></td></tr>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="5%"></td>
<td width="3%"></td>
<td width="4%"></td>
<td width="85%">
</td></tr>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="5%"></td>
<td width="3%"></td>
<td width="4%"></td>
<td width="85%">
</td></tr>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="5%"></td>
<td width="3%"></td>
<td width="4%"></td>
<td width="85%">
</td></tr>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="5%"></td>
<td width="3%"></td>
<td width="4%"></td>
<td width="85%">


<p>(here --&gt;)}</p></td></tr>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="5%"></td>
<td width="3%"></td>
<td width="4%"></td>
<td width="85%">
</td></tr>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="5%"></td>
<td width="3%"></td>
<td width="4%"></td>
<td width="85%">
</td></tr>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="5%"></td>
<td width="3%"></td>
<td width="4%"></td>
<td width="85%">


<p>}</p></td></tr>
</table>

<h2>KEYWORDS
<a name="KEYWORDS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">json, parsing,
formatting</p>
<hr>
</body>
</html>
